(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{215:function(t,e,r){t.exports=r.p+"assets/img/domtree.80d088b8.png"},216:function(t,e,r){t.exports=r.p+"assets/img/csstree.41102639.png"},217:function(t,e,r){t.exports=r.p+"assets/img/rendertree.27df2850.png"},218:function(t,e,r){t.exports=r.p+"assets/img/updatestyle.b9bea0f8.png"},260:function(t,e,r){"use strict";r.r(e);var s=r(0),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"浏览器渲染原理-乞丐版"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染原理-乞丐版"}},[t._v("#")]),t._v(" 浏览器渲染原理(乞丐版)")]),t._v(" "),s("h2",{attrs:{id:"渲染树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#渲染树"}},[t._v("#")]),t._v(" 渲染树")]),t._v(" "),s("p",[t._v("当浏览器拿到 HTML 和 CSS 文件时必不可少的一步就是构建渲染树.什么是渲染树?它是做什么的?接下来将会 cover 到.")]),t._v(" "),s("p",[t._v("首先浏览器拿到 HTML 文件就开始构建 DOM 树.它将从 HTML 文件的顶部元素作为根节点,然后按照父子兄弟元素层级关系来构建出类似于树形结构的数据结构.\n"),s("img",{attrs:{src:r(215),alt:"DOM Tree"}})]),t._v(" "),s("p",[t._v("然后就是解析 CSS 文件,和 HTML 的 DOM 树类似.它会在 DOM 树的结构基础上为节点添加样式, 至于哪些加,哪些不加是根据 CSS 文件决定.最后生成 CSS 树.\n"),s("img",{attrs:{src:r(216),alt:"CSS Tree"}})]),t._v(" "),s("p",[t._v("接下来,浏览器要做的就是合并 DOM 和 CSSOM.合成的树就是渲染树(render tree).它相当于一个建筑的设计图,决定了这个建筑的结构,外观等等.接下来的事情就是根据渲染树渲染内容给浏览器的用户看.\n"),s("img",{attrs:{src:r(217),alt:"render tree"}})]),t._v(" "),s("h2",{attrs:{id:"布局-绘制-组合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#布局-绘制-组合"}},[t._v("#")]),t._v(" 布局, 绘制, 组合")]),t._v(" "),s("p",[t._v("首先是进行布局(Layout), 它计算盒模型的位置,大小.按照文档流排列,如果有元素脱离文档流也要计算一下.然后开始绘制(Paint), 这一步就是将计算好的布局一个个排列到屏幕的像素点上.它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。.在最后的组合(Composite)环节根据层叠关系展示画面.最终为用户所见到的内容.")]),t._v(" "),s("h2",{attrs:{id:"更新样式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#更新样式"}},[t._v("#")]),t._v(" 更新样式")]),t._v(" "),s("p",[t._v("通常使用 JavaScript 来改变页面的布局或者样式.既然布局或者样式更改了, 那么将会触发更新.更新的方式有三种:\n"),s("img",{attrs:{src:r(218),alt:"update style"}}),t._v("\n如果您更改一个既不要布局也不要绘制的属性,则浏览器将跳到只执行合成.")]),t._v(" "),s("p",[t._v("这个最后的版本开销最小，最适合于应用生命周期中的高压力点,例如动画或滚动.")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("小贴士")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://csstriggers.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("csstriggers.com"),s("OutboundLink")],1),t._v("是一个能检测所有 CSS 属性触发了哪些流程的网站, 非常有用.")])]),t._v(" "),s("h2",{attrs:{id:"参考链接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[t._v("#")]),t._v(" 参考链接")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction",target:"_blank",rel:"noopener noreferrer"}},[t._v("Render-tree Construction, Layout, and Paint"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://developers.google.com/web/fundamentals/performance/rendering/",target:"_blank",rel:"noopener noreferrer"}},[t._v("渲染性能"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=a.exports}}]);